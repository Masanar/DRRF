<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>DRRF</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <header>
      <nav>
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="observables.html">Observables</a></li>
          <li><a href="#">Observers</a></li>
          <li><a href="#">Examples</a></li>

          <!-- <li><a href="examples.html">Examples</a></li> -->
        </ul>
      </nav>
    </header>

        <section class="main">
          <section class="articles">
            <article>
              <h2>A Brief Review on Temporal Logic Models </h2>
              <br>
              <p>
                We need to define the semantics of the LTL operators. In this way, we show a brief review of LTL semantics, for a deep introduction to Temporal Logic you can see <a href="https://onlinelibrary.wiley.com/doi/book/10.1002/9781119991472">Fisher</a>. The following finite model of time for  the  <strong>next in the future</strong>  operator. This operator provide us the ability to represent properties that will be true at the next moment, from the moment when the next operator was evaluated.
              </p>
                <br>
                <img src="next.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;"  class="center" />
                <br>
              <p>
                Analogous, the following finite model of time for  the <strong>eventually in the future</strong>  operator, let us represent properties that are true at the some point in time from now. We know that they will be true, but we do not know when they will be.
              </p>
                <img src="eventually.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;" class="center" />
                <br>
              <p>
                Alike, the following finite model of time for  the <strong>always in the future</strong>. This operator give us the control to represent properties that are true at all moments in time from now on.
              </p>
                <img src="always.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;" class="center" />
                <br>
              <p>
                Likewise, there are different patterns (combinations of a temporal operator) that are remarkable, take a look at the following models:

              </p>
              <br>
              <img src="remarkable1.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;" class="center" />
              <br>
              <img src="remarkable2.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;" class="center" />
              <br>
              <p>
                Those are behaviors that we have to take into account because a naive implementation of those patterns will become in a bad interpretation of LTL semantics. The evaluation of the first formula &#x25A1;(&Omicron;&Phi;) implies that at every moment (after the evaluation)  &Omicron;&Phi; must be true. This means that &Phi; must be true after the second moment when the whole formula was evaluated. The evaluation of the second formula &#x25C7;(&Omicron;&gamma;) implies that after the moment when the formula has evaluated there is a moment where the formula  must be true. That is to say, the formula &gamma; must be true after the second moment since the whole formula has been evaluated. For this reason the operations <code>heredity</code>.
              </p>
              <br>
              <h2>LTL Semantics</h2>
              <br>
              <p>
                We use LTL operators to specify behavior, the data flow throughout the execution system and constraints in the base application. The module <code>LTL</code>  defines the temporal logic operators as Maude operations. Notice that LTL operators are defined as operations whit domain is <code>LTL</code> and which range is <code>LTL</code> (i.e they received LTL formulas and produce new LTL formulas).
              </p>
              <br>
              <section>

                <details>
                  <summary> <code>~_</code> Logical complement. </summary>
                  <br>
                  <pre><code>
        op ~_ : Ltl -> Ltl [ctor prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_/\_</code> Logical conjunction. </summary>
                  <br>
                  <pre><code>
        op _/\_ : Ltl Ltl -> Ltl [comm ctor gather (E e) prec 55 format (d r o d)] .

                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_\/_</code> Logical disjunction. </summary>
                  <br>
                  <pre><code>
        op _\/_ : Ltl Ltl -> Ltl [comm ctor gather (E e) prec 59 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_->_</code>Logical implication. </summary>
                  <br>
                  <pre><code>
        op _->_ : Ltl Ltl -> Ltl [gather (e E) prec 65 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_<->_</code>Logical equivalence. </summary>
                  <br>
                  <pre><code>
        op _<->_ : Ltl Ltl -> Ltl [prec 65 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>O_</code> Temporal operator next. </summary>
                  <br>
                  <pre><code>
        op O_ : Ltl -> Ltl [ctor prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>E_</code> Temporal operator eventually. </summary>
                  <br>
                  <pre><code>
        op E_ : Ltl -> Ltl [prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>[]_</code> Temporal operator always in the future. </summary>
                  <br>
                  <pre><code>
        op []_ : Ltl -> Ltl [prec 53 format (r d o d)] .
                  </code></pre>
                  <br>
                </details>

              </section>
              <br>
              <p>
                As we mentionted above, we defined the semantics of LTL formulas using the opertaion <code> heredity</code> and <code> verification</code>. This operation  recur over the structure (syntax tree) of the LTL formula up to the base cases: Predicates and Constants. Moreover, the propocitional logic semantics is defined as usal, for more deatail you can see the entire <code>Temporal-logic.maude</code> file . The operation <code>verification</code> has two argumments the LTL formula and the configuration where the formula want to be evaluated, notice that different configuration generate different results for the same formula.
              </p>

              <br>


              <pre><code>
      op heredity       : Ltl Ltl                    -> Ltl .
      op verification   : Ltl Configuration          -> Ltl  .
      var Con : Configuration .
      vars LT LT' LT'' : Ltl .
      var PR : Pred .
      eq verification(true,Con) = true .
      eq verification(false,Con) = false .
      eq verification(~ LT,Con) = ~ verification(LT,Con) .
      eq verification(LT /\ LT',Con) = verification(LT,Con) /\ verification(LT',Con) .
      eq verification(LT \/ LT',Con) = verification(LT,Con) \/ verification(LT',Con) .
      eq verification(LT -> LT',Con) = verification(LT,Con) -> verification(LT',Con) .

              </code> </pre>
              <br>
              <p>
                The semantics for LTL operators is quite different. Each time that a next operation is evaluated &Omicron;&gamma;, the formula is  changed to  &gamma; in this way the next moment the formula that must be evaluated &gamma;. Each time that a eventually operator is evaluated &#x25C7;&gamma; the value of the fomula &gamma; is verified, if it is true &#x25C7;&gamma; is evaluted as ture and if it is false the formula no change in order to be evaluated at the next moment. Finally, evaluate a &#x25A1;&gamma; formula implies evaluate the formula &gamma; if it is false &#x25A1;&gamma; is evaluted as false   if it is true the formula no change in order to be evaluated at the next moment.
              </p>
              <br>
              <pre> <code>
      eq verification(E(LT),Con) = if verification((LT),Con)
         then true
         else E(LT)
         fi .
      eq verification(O(LT),Con) = LT .
      eq verification([](LT),Con) = if (verification(LT,Con) == false)
         then false
         else [](LT)
         fi .
              </code> </pre>
              <br>
              <p>
                All the more, as is mention above, the semantics for the remarkable patterns is taking into account, in this way we define the operation <code>heredity</code>. For the pattern &#x25A1;(&Omicron;&gamma;) the first argument keeps the information of the formula while the second argument keeps the formula &Omicron;&gamma; to be evaluated at the next moment. For the other remarkable pattern, the operation <code>heredity</code> works in the same way.
              </p>
              <br>
              <pre> <code>
      eq verification([](O(LT)),Con) = heredity([](O(LT)),O(LT)) .
      eq verification(heredity(LT,O(LT'))) = heredity(LT,LT') .
      eq verification(heredity(LT,LT'),Con) = if (verification(LT',Con) == false)
         then false
         else heredity(LT,LT')
         fi .
              </code> </pre>
              <br>
            </article>
            <article >
              <h2>Observers</h2>
              <br>
              <p>
                Module <code>SYSTEM-CHECK</code> defines observers of type checker. These Observers are defined with a LTL formula and are in charge of monitoring specific behaviors. The association of an observer with an observable system ( Consumer or a Producer) is made using the identifier of the objects, i.e., a checker and the observable it is associated to must have the same identifier (remember that in Muade the identity of and object depends of its type and its identifier). Additionally, monitors use LTL formulas aiming to look out the observable associated with it. Then, when the temporal formulas that the checker verifies are not fulfilled a reaction can be generated (if it was defined).
              </p>
              <br>
              
            </article>

          </section>
        </section>
        <footer>
          <p>
            Mateo Sanabria Ardila- Mateo.sanabria@escuelaing.edu.co
          </p>
        </footer>



  </body>
</html>
