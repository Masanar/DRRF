<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>DRRF</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <header>
      <nav>
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="observables.html">Observables</a></li>
          <li><a href="#">Observers</a></li>
          <li><a href="#">Examples</a></li>

          <!-- <li><a href="examples.html">Examples</a></li> -->
        </ul>
      </nav>
    </header>

        <section class="main">
          <section class="articles">
            <article>
              <h2>Observers</h2>
              <br>
              <p>
                We use LTL operators to specify behavior, the data flow throughout the execution system and constraints in the base application. The module <code>LTL</code>  defines the temporal logic operators as Maude operations. Notice that LTL operators are defined as operations whit domain is <code>LTL</code> and which range is <code>LTL</code> (i.e they received LTL formulas and produce new LTL formulas).
              </p>
              <br>
              <section>

                <details>
                  <summary> <code>~_</code> Logical complement. </summary>
                  <br>
                  <pre><code>
        op ~_ : Ltl -> Ltl [ctor prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_/\_</code> Logical conjunction. </summary>
                  <br>
                  <pre><code>
        op _/\_ : Ltl Ltl -> Ltl [comm ctor gather (E e) prec 55 format (d r o d)] .

                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_\/_</code> Logical disjunction. </summary>
                  <br>
                  <pre><code>
        op _\/_ : Ltl Ltl -> Ltl [comm ctor gather (E e) prec 59 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_->_</code>Logical implication. </summary>
                  <br>
                  <pre><code>
        op _->_ : Ltl Ltl -> Ltl [gather (e E) prec 65 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_<->_</code>Logical equivalence. </summary>
                  <br>
                  <pre><code>
        op _<->_ : Ltl Ltl -> Ltl [prec 65 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>O_</code> Temporal operator next. </summary>
                  <br>
                  <pre><code>
        op O_ : Ltl -> Ltl [ctor prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>E_</code> Temporal operator eventually. </summary>
                  <br>
                  <pre><code>
        op E_ : Ltl -> Ltl [prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>[]_</code> Temporal operator globally. </summary>
                  <br>
                  <pre><code>
        op []_ : Ltl -> Ltl [prec 53 format (r d o d)] .
                  </code></pre>
                  <br>
                </details>

              </section>
              <br>
              <p>
                However, it is necessary to define the semantics of these operators (for a breaf introduction to Temporal Logic you can read <a href="https://onlinelibrary.wiley.com/doi/book/10.1002/9781119991472">Fisher</a>). Note the following example 

                For this reason the operations <code>heredity</code> and <code>verification</code> were  defined
              </p>
              <br>
              <pre><code>
      op heredity       : Ltl Ltl                    -> Ltl .
      op verification   : Ltl Configuration          -> Ltl  .
      var Con : Configuration .
      vars LT LT' LT'' : Ltl .
      var PR : Pred .
              </code></pre>
              <br>
              <pre> <code>
      eq verification(true,Con) = true .
      eq verification(false,Con) = false .
      eq verification(~ LT,Con) = ~ verification(LT,Con) .
      eq verification(LT /\ LT',Con) = verification(LT,Con) /\ verification(LT',Con) .
      eq verification(LT \/ LT',Con) = verification(LT,Con) \/ verification(LT',Con) .
      eq verification(LT -> LT',Con) = verification(LT,Con) -> verification(LT',Con) .

              </code> </pre>
              <br>
              <pre> <code>
      eq verification(O(LT),Con) = LT .
      eq verification([](O(LT)),Con) = heredity([](O(LT)),LT) .
      eq verification(heredity(LT,LT'),Con) = if (verification(LT',Con) == false)
         then false
         else heredity(LT,LT')
         fi .
      eq verification([](LT),Con) = if (verification(LT,Con) == false)
         then false
         else [](LT)
         fi .
      eq verification(E(LT),Con) = if verification((LT),Con)
         then true
         else E(LT)
         fi .
              </code> </pre>
              <br>
            </article>

          </section>
        </section>
        <footer>
          <p>
            Mateo Sanabria Ardila- Mateo.sanabria@escuelaing.edu.co
          </p>
        </footer>



  </body>
</html>
