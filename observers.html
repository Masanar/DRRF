<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>DRRF</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <header>
      <nav>
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="observables.html">Observables</a></li>
          <li><a href="#">Observers</a></li>
          <li><a href="examples.html">Examples</a></li>

          <!-- <li><a href="examples.html">Examples</a></li> -->
        </ul>
      </nav>
    </header>

        <section class="main">
          <section class="articles">
            <article>
              <h2>A Brief Review on Temporal Logic Models </h2>
              <br>
              <p>
                We need to define the semantics of the LTL operators. In this way, we show a brief review of LTL semantics, for a deep introduction to Temporal Logic you can see <a href="https://onlinelibrary.wiley.com/doi/book/10.1002/9781119991472">Fisher</a>. The following finite model of time for  the  <strong>next in the future</strong>  operator. This operator provides us the ability to represent properties that will be true at the next moment, from the moment when the next operator was evaluated.
              </p>
                <br>
                <img src="next.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;"  class="center" />
                <br>
              <p>
                Analogous, the following finite model of time for  the <strong>eventually in the future</strong>  operator, let us represent properties that are true at some point in time from now. We know that they will be true, but we do not know when they will be.
              </p>
                <img src="eventually.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;" class="center" />
                <br>
              <p>
                Alike, the following finite model of time for  the <strong>always in the future</strong>. This operator gives us the control to represent properties that are true at all moments in time from now on.
              </p>
                <img src="always.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;" class="center" />
                <br>
              <p>
                Likewise, there are different patterns (combinations of  temporal operators) that are remarkable, take a look at the following models:

              </p>
              <br>
              <img src="remarkable1.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;" class="center" />
              <br>
              <img src="remarkable2.png" alt="model of time for the ‘always in the future’ operator" style="max-width: 75%;" class="center" />
              <br>
              <p>
                Those are behaviors that we have to take into account because a naive implementation of those patterns will become in a bad interpretation of LTL semantics. The evaluation of the first formula &#x25A1;(&Omicron;&Phi;) implies that at every moment (after the evaluation)  &Omicron;&Phi; must be true. This means that &Phi; must be true after the second moment when the whole formula was evaluated. The evaluation of the second formula &#x25C7;(&Omicron;&gamma;) implies that after the moment when the formula has evaluated there is a moment where the formula  must be true. That is to say, the formula &gamma; must be true after the second moment since the whole formula has been evaluated. For this reason the operations <code>heredity</code>.
              </p>
              <br>
              <h2>LTL Semantics</h2>
              <br>
              <p>
                We use LTL operators to specify behavior, the data flow throughout the execution system and constraints in the base application. The module <code>LTL</code>  defines the temporal logic operators as Maude operations. Notice that LTL operators are defined as operations whit domain is <code>LTL</code> and which range is <code>LTL</code> (i.e they received LTL formulas and produce new LTL formulas).
              </p>
              <br>
              <section>

                <details>
                  <summary> <code>~_</code> Logical complement. </summary>
                  <br>
                  <pre><code>
        op ~_ : Ltl -> Ltl [ctor prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_/\_</code> Logical conjunction. </summary>
                  <br>
                  <pre><code>
        op _/\_ : Ltl Ltl -> Ltl [comm ctor gather (E e) prec 55 format (d r o d)] .

                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_\/_</code> Logical disjunction. </summary>
                  <br>
                  <pre><code>
        op _\/_ : Ltl Ltl -> Ltl [comm ctor gather (E e) prec 59 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_->_</code>Logical implication. </summary>
                  <br>
                  <pre><code>
        op _->_ : Ltl Ltl -> Ltl [gather (e E) prec 65 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>_<->_</code>Logical equivalence. </summary>
                  <br>
                  <pre><code>
        op _<->_ : Ltl Ltl -> Ltl [prec 65 format (d r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>O_</code> Temporal operator next. </summary>
                  <br>
                  <pre><code>
        op O_ : Ltl -> Ltl [ctor prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>E_</code> Temporal operator eventually. </summary>
                  <br>
                  <pre><code>
        op E_ : Ltl -> Ltl [prec 53 format (r o d)] .
                  </code></pre>
                  <br>
                </details>

                <details>
                  <summary> <code>[]_</code> Temporal operator always in the future. </summary>
                  <br>
                  <pre><code>
        op []_ : Ltl -> Ltl [prec 53 format (r d o d)] .
                  </code></pre>
                  <br>
                </details>

              </section>
              <br>
              <p>
                As we mentioned above, we defined the semantics of LTL formulas using the operation code> heredity</code> and <code> verification</code>. This operation recurs over the structure (syntax tree) of the LTL formula up to the base cases: Predicates and Constants. Moreover, the propositional logic semantics is defined as usual, for more detail you can see the entire <code>Temporal-logic.maude</code> file . The operation <code>verification</code> has two arguments the LTL formula and the configuration where the formula want to be evaluated, notice that different configuration generate different results for the same formula.
              </p>

              <br>


              <pre><code>
      op heredity       : Ltl Ltl                    -> Ltl .
      op verification   : Ltl Configuration          -> Ltl  .
      var Con : Configuration .
      vars LT LT' LT'' : Ltl .
      var PR : Pred .
      eq verification(true,Con) = true .
      eq verification(false,Con) = false .
      eq verification(~ LT,Con) = ~ verification(LT,Con) .
      eq verification(LT /\ LT',Con) = verification(LT,Con) /\ verification(LT',Con) .
      eq verification(LT \/ LT',Con) = verification(LT,Con) \/ verification(LT',Con) .
      eq verification(LT -> LT',Con) = verification(LT,Con) -> verification(LT',Con) .

              </code> </pre>
              <br>
              <p>
                The semantics for LTL operators is quite different. Each time that a next operation is evaluated &Omicron;&gamma;, the formula is changed to  &gamma; in this way the next moment the formula that must be evaluated  &gamma;. Each time that an eventual operator is evaluated &#x25C7;&gamma;  the value of the formula &gamma; is verified, if it is true &#x25C7;&gamma;  is evaluated as true and if it is false the formula no change in order to be evaluated at the next moment. Finally, evaluate a &#x25A1;&gamma; formula implies to evaluate the formula &gamma; if it is false &#x25A1;&gamma; is evaluated as false if it is true the formula no change in order to be evaluated at the next moment.

              </p>
              <br>
              <pre> <code>
      eq verification(E(LT),Con) = if verification((LT),Con)
         then true
         else E(LT)
         fi .
      eq verification(O(LT),Con) = LT .
      eq verification([](LT),Con) = if (verification(LT,Con) == false)
         then false
         else [](LT)
         fi .
              </code> </pre>
              <br>
              <p>
                All the more, as is mention above, the semantics for the remarkable patterns is taking into account, in this way we define the operation <code>heredity</code>. For the pattern &#x25A1;(&Omicron;&gamma;) the first argument keeps the information of the formula while the second argument keeps the formula &Omicron;&gamma; to be evaluated at the next moment. For the other remarkable pattern, the operation <code>heredity</code> works in the same way.
              </p>
              <br>
              <pre> <code>
      eq verification([](O(LT)),Con) = heredity([](O(LT)),O(LT)) .
      eq verification(heredity(LT,O(LT'))) = heredity(LT,LT') .
      eq verification(heredity(LT,LT'),Con) = if (verification(LT',Con) == false)
         then false
         else heredity(LT,LT')
         fi .
              </code> </pre>
              <br>
            </article>
            <article>
              <h2>Predicates Definition</h2>
              <br>
              <p>If you want to define new predicates for observers to monitor a specific behavior in the data flow, you have to modify the file <code>Predicate.maude</code> in this file you will find the syntaxis for predicate definition.
              </p>
              <br>
              <pre> <code>

    mod PREDICATES is
      pr STRING . pr RULES  .  including LTL .
      --- pr MULTI-STEP-ATACK .
      op _|-_           : Sys  Ltl  -> Ltl .
      op partial-order  : Nat       -> Pred .
      op _Causality_    : Nat Nat   -> Pred .
      op Acces-market-D : Nat       -> Pred .
      op App-download-D : Nat       -> Pred .
      op Payload-D      : Nat       -> Pred .
      op Scanning-D     : Nat       -> Pred .
      op Injection-D    : Nat       -> Pred .
      op Order_         : Nat       -> Pred .
      op Order_of_ : Nat Nat -> Pred .
      ...
      --- Causality detection over Consumers
      ceq { < RC : Consumer | ATS , clock-c: VC > Con } |- (RC Causality SE) = true
        if ic(VC,SE) > 0 .
      eq { Con } |- (RC Causality SE) = false   [owise] .
      ...
    endm
              </code> </pre>
              <p>
                For example, the predicate <code> Causality </code> is defined by specifying in what state it is valid and any other state that this will be invalid(<code>owise</code>).
              </p>
            </article>
            <article >
              <h2>Observers: checkers</h2>
              <br>
              <p>
                Module <code>SYSTEM-CHECK</code> defines observers of the type checker. These Observers are defined with an LTL formula and are in charge of monitoring specific behaviors. The association of an observer with an observable system ( Consumer or a Producer) is made using the identifier of the objects, i.e., a checker and the observable it is associated to must have the same identifier (remember that in Maude the identity of an object depends on its type and its identifier). Additionally, monitors use LTL formulas aiming to look out the observable associated with it. Then, when the temporal formulas that the checker verifies are not fulfilled a reaction can be generated (if it was defined).
              </p>
              <br>
              <p>
                There are several attributes that allow the observer definition. For example, the attribute <code>formula</code> that saves the formula that the observer must verify through the execution. Besides, the attributes <code> end-c</code> and <code>count</code> the finish of execution.
              </p>
              <br>
              <p>
                As we mentioned previously we use the module <code>CONFIGURATION</code> aiming to define the particular objects, messages, and rules for interaction that are of interest. Thus, part of the definition of Producers is the following:
              </p>
              <br>            <br>
              <pre><code>
      op checker        :                          -> Cid           .
      op Formula:_      : Ltl                      -> Attribute     .
      op end-c:_        : Nat                      -> Attribute     .
      op count:_        : Nat                      -> Attribute     .
              </code> </pre>
              <br>
              <p>
                In this way a complex base application whit several observables, one Producer, three Consumers and two checkers one associated to Producer 1 and the other related to Consumer 1. Is the following:
              </p>
              <br>
              <pre> <code>
      < 0 : Producer | cnt-prod: 0,frequency: 1,clock-p: (0 0 0 0 0),weights: 2,end: 7,finish: false,Notice-logs: nil >
      < 1 : Consumer | current-mesg: none,freq-C: 2,actual-time: 0,logs: nil,limit: 20, clock-c:(0 0 0 0 0 ) >
      < 2 : Consumer | current-mesg: none,freq-C: 1,actual-time: 0,logs: nil,limit: 20, clock-c:(0 0 0 0 0 ) >
      < 3 : Consumer | current-mesg: none,freq-C: 5,actual-time: 0,logs: nil,limit: 20, clock-c:(0 0 0 0 0 ) >
      < 0 : checker | Formula: (E (Order 0 of 1)) , finish: false , count: 0 , end-c: 50 >
      < 1 : checker | Formula: (E (Order 1 of 0)) , finish: false , count: 0 , end-c: 50 >
              </code> </pre>
              <br>
              <h2> Dynamic behavior</h2>
              <br>
              <p>
                In Maude, we have specified the rules that represent dynamic behavior. Rules model concurrent transitions that can take place in the system. If the pattern in the rule’s left-hand side matches a fragment of the system state and the rule’s condition is satisfied. In that case, the rule can take place, and the matched fragment of the state is transformed into the corresponding instance of the right-hand side. In this way, a rule is defined to model observer behavior. Notice that several variables are used because rules only need to mention the attributes and objects strictly necessary for a model of concurrent transitions. Thus, <code>ATS</code> refers to a variable of type <code> AttributeSet </code> and <code>Con</code> refers to a variable of type <code>Configuration</code>, the other variables are related to his correspondent attribute type.
              </p>
              <br>


              <details>
                <summary> <code>[checker-Predicate]</code> </summary>
                <br>
                <p>
                  Each time that this rule is done the checker verifies the validity of formula saves in attribute <code>Formula</code> through the configuration at the moment when the rule was applied, using the operation <code> verification</code> define above. Notice that this is a conditional rule then it can be replicated only if the count is less or equal than the number defined at attribute <code>end-c</code>.
                </p>
                <br>
                <pre><code>
      crl [checker-Predicate] :
      { < RC : checker | Formula: TL , finish: false, count: N , end-c: END >  Con }
      =>
      { < RC : checker | Formula: verification(TL,Con) , finish: false, count: s(N), end-c: END  >  Con }

      if N <= END
      .
                </code></pre>
                <br>
              </details>

            </article>

          </section>
        </section>
        <footer>
          <p>
            Mateo Sanabria Ardila- Mateo.sanabria@escuelaing.edu.co
          </p>
        </footer>



  </body>
</html>
