load vector.maude
mod PRODUCER is
  pr NAT . pr STRING  . pr BOOL . pr VECTOR .
  inc CONFIGURATION . pr LIST{String} .
  subsort Nat < Oid .
  op prod-finish          :  Nat                -> Msg       [format(n! o)].
  op Unordered-mesg       :  Nat Nat Nat Vector -> Msg       [format(n! o)].
  op Producer             :                     -> Cid       [format (y! o)] .
  op cnt-prod:_           :  Nat                -> Attribute .
  op frequency:_          :  Nat                -> Attribute .
  op clock-p:_            :  Vector             -> Attribute  .
  op weights:_            :  Nat                -> Attribute .
  op end:_                :  Nat                -> Attribute .
  op finish:_             :  Bool               -> Attribute .
  op init-prod            :  Nat  Nat Nat Nat -> Object    .
  op Notice-logs:_        :  List{String}  ->  Attribute  .
  vars WE ST END FR : Nat .
  eq init-prod(ST,WE,FR,END)
   = < ST : Producer | finish: false , cnt-prod: 0 , weights: WE , frequency: FR , clock-p: 0 , end: END, Notice-logs: nil  > .
endm

mod CONSUMER is
  pr NAT . pr STRING  . pr LIST{String} . pr VECTOR .
  inc CONFIGURATION .
  subsort Nat < Oid .
  --- Nat1: quien lo recive, Nat2: el que lo evio
  --- If you want to be precise, you may define another object: Sentinela.
  --- The Sentinela would take care of detec the Payload download in a Consumer.
  op init-consumer        :  Nat Nat Nat Vector     ->  Object     .
  op Consumer             :                  ->  Cid        [format (c! o)] .
  op Notice-mesg          :  Nat Nat Vector  ->  Msg        [format(n! o)] .
  op none                 :                  ->  Msg     [ctor]   .
  op current-mesg:_       :  Msg             ->  Attribute  .
  op freq-C:_             :  Nat             ->  Attribute  .
  op actual-time:_        :  Nat             ->  Attribute  .
  op logs:_               :  List{String}    ->  Attribute  .
  op limit:_              :  Nat             ->  Attribute  .
  op clock-c:_            :  Vector          ->  Attribute  .
  var FR CO LT : Nat . var vec : Vector .
  eq init-consumer(CO,FR,LT,vec)
   = < CO : Consumer | clock-c: vec , freq-C: FR , actual-time: 0 , logs: nil , current-mesg: none, limit: LT  > .
endm

mod RULES is
  inc CONFIGURATION .  pr CONVERSION .
  pr CONSUMER . pr PRODUCER . pr VECTOR .
  sort Sys .
  op {_} : Configuration -> Sys [format(n d d n)].

  var QS : List{String} . vars N T T' FR CT' END PR CS LT : Nat .  var Con : Configuration .
  var ATS : AttributeSet . var CT TS CL VC : Vector .

  crl [update-time-Producer] :
  { < PR : Producer | ATS ,  clock-p: CL , end: END , cnt-prod: CT' >  Con }
  =>
  { < PR : Producer | ATS ,  clock-p: tick(CL,PR)  , end: END , cnt-prod: CT'  >  Con }
  if CT' < END
  .
  crl [update-time-Consumer] :
  { < PR : Consumer | ATS , freq-C: FR , clock-c: CL , current-mesg: none ,  limit: LT >  Con }
  =>
  { < PR : Consumer | ATS , freq-C: FR , clock-c: tick(CL,PR) , current-mesg: none ,  limit: LT >  Con }
  if ic(CL,PR) <= LT
  .



  crl [send-msg]:
   { < PR : Producer | ATS , cnt-prod: N , weights:  T  , frequency: FR , clock-p: TS, end: END >  Con }
   =>
   { < PR : Producer | ATS , cnt-prod: s(N) , weights: T , frequency: FR , clock-p: tick(TS,PR), end: END  >
     Unordered-mesg(PR,N,T,TS)  Con }
  if FR divides ic(TS,PR) /\ (END > N) /\ (ic(TS,PR) =/= 0)
  .


  crl [Consumer-msg]:
   { Unordered-mesg(PR,N,T,TS)
    < CS : Consumer | ATS , current-mesg: none , freq-C: FR , clock-c: CL, limit: LT >  Con }
   =>
   {< CS : Consumer | ATS , current-mesg: Unordered-mesg(PR,N,T,TS) , freq-C: FR , clock-c: tick(maxv(CL,TS),CS) , limit: LT  >
    Notice-mesg(CS,PR,tick(maxv(CL,TS),CS)) Con }
  if (FR divides ic(CL,CS)) /\  ic(CL,CS) <= LT
  .


  rl [Consumer-notice]:
   { Notice-mesg(CS,PR,VC)
    < PR : Producer | ATS ,clock-p: CL, Notice-logs: QS >  Con }
   =>
   {< PR : Producer | ATS ,clock-p: tick(maxv(CL,VC),PR),Notice-logs: (QS (string(CS,10) + "_" + string(ic(CL,PR), 10)))  >
     Con }
  .

  crl [Consuming-msg]:
   {< CS : Consumer | ATS , actual-time: T' , logs: QS , clock-c: CL ,current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
   =>
   {< CS : Consumer | ATS , actual-time: s(T') , logs: QS , clock-c: tick(CL,CS) ,current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
  if  s(T') <= T
  .

  crl [end-msg]:
   {< CS : Consumer | ATS , actual-time: T' , clock-c: CL , logs: QS , current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
   =>
   {< CS : Consumer | ATS , actual-time: 0 , clock-c: tick(CL,CS) ,logs: (QS (string(PR,10) + "_" + string(N, 10) + "_" + string(T, 10) ) )  , current-mesg: none >  Con }
  if  T' = T
  .

  rl [send-end] :
  { < PR : Producer | ATS ,  cnt-prod: END , end: END , finish: false >  Con }
  =>
  { < PR : Producer | ATS ,  cnt-prod: END , end: END , finish: true > prod-finish(PR) Con }
  .


endm
--- rew {
--- < 0 : Producer | cnt-prod: 0,frequency: 1,clock-p: (0 0 0 0 0),weights: 5,end: 10,finish: false,Notice-logs: nil >
--- < 1 : Producer | cnt-prod: 0,frequency: 3,clock-p: (0 0 0 0 0),weights: 1,end: 10,finish: false,Notice-logs: nil >
--- < 2 : Consumer | current-mesg: none,freq-C: 2,actual-time: 0,logs: nil,limit: 34, clock-c:(0 0 0 0 0) >
--- < 3 : Consumer | current-mesg: none,freq-C: 1,actual-time: 0,logs: nil,limit: 30, clock-c:(0 0 0 0 0) >
--- < 4 : Consumer | current-mesg: none,freq-C: 5,actual-time: 0,logs: nil,limit: 55, clock-c:(0 0 0 0 0) >
--- }
--- .
eof
