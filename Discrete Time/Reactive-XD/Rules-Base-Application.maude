fmod DISCRTE-TIME is

  pr NAT .
  sorts Time NzTime .
  subsort NzTime < Time .
  subsort Nat < Time .
  subsort NzNat < NzTime .

  op zero : -> Time .
  op _plus_ : Time Time -> Time [assoc comm prec 33 gather (E e)] .
  op _monus_ : Time Time -> Time [prec 33 gather (E e)] .

  vars N N' : Nat .
  eq zero = 0 .
  eq N plus N' = N + N' .
  eq N monus N' = if N > N' then sd(N, N') else 0 fi .
  eq zero plus R:Time = R:Time .

endfm

view Time from TRIV to DISCRTE-TIME is
  sort Elt to Time .
endv

mod VECTOR is
  pr NAT .
  pr LIST{Time} .
  sort Vector .
  subsorts Time < List{Time} < Vector .
  ---Operation definition:
  ---   tick: Update the vector clock
  ---   <v: Define the order in the vector-matter-space
  ---   maxv: Gives the max between two vectors as  the order say
  ---   ic(Vec,n): Gives the n clock of the vector vec (ic == individual clock)
  op tick : Vector Time   -> Vector  .
  op _<v_ : Vector Vector -> Bool    .
  op maxv : Vector Vector -> Vector  .
  op ic   : Vector Time    -> Time     .

  ---Variables definition
  var N V : Time .
  vars vec vec' : Vector .


  ---Semantic's for clock ticking
  --- eq tick(V,N) = s(V) .
  --- eq tick(V vec,0) = s(V) vec .
  --- eq tick(V vec,N) = V tick(vec,sd(N,1)) .
  --- El tick por defecto aumenta el reloj en una unidad
  eq tick(V,N) = (V plus 1) .
  eq tick(V vec,0) = (V plus 1) vec .
  eq tick(V vec,N) = V tick(vec,(N monus 1)) .

  ---Semantic's for order definition
  ---These instructions are for compare all pair of vectors

  ceq vec <v vec' = false
    if size(vec) < size(vec') .
  ceq vec <v vec' = false
    if size(vec') < size(vec) .
  ---Recursion definition for the order
  ceq N <v  V = false
    if V <= N .
  ceq N <v  V = true
    if N < V .
  ceq (N vec) <v (V vec') = false
    if (V <= N) .
  ceq (N vec) <v (V vec') = vec <v vec'
    if (N <= V) .
  ---Semantic for maxv operator
  ---Notice the maxv operation for two vector that have differents size is define too!
  ---
  ---if all works ok then if you are in a n-process an you have to update the vector clock
  ---beacouse the process gets a message the n-clock do not have to be update (exect the tick)
  ---
  eq maxv(nil,nil) = nil .
  eq maxv(nil,vec) = vec .
  eq maxv(vec,nil) = vec .
  eq maxv(N,V) = max(N,V) .
  eq maxv( N vec, V vec') = max(N,V) maxv(vec,vec') .

  ---Semantics for ic
  eq  ic(V,N)= V .
  eq  ic(V vec,0) = V .
  ceq ic(V vec,N) = ic(vec,sd(N,1))
    if N > 0 .

endm

mod TUPLE is
  sorts 3Tuple Tuple . pr NAT . pr VECTOR .
  op |_;_;_|   : Nat Nat Vector -> 3Tuple [ctor] .
  op |_;_;_;_| : Nat Nat Nat Nat -> Tuple [ctor] .
endm

view 3Tuple from TRIV to TUPLE is
  sort Elt to 3Tuple .
endv
view 4Tuple from TRIV to TUPLE is
  sort Elt to Tuple .
endv

mod PRODUCER is
  pr NAT . pr STRING  . pr BOOL . pr VECTOR . pr TUPLE .
  inc CONFIGURATION .  pr LIST{4Tuple} .
  subsort Nat < Oid .
  op prod-finish          :  Nat                -> Msg       [format(n! o)].
  op Unordered-mesg       :  Nat Nat Nat Vector -> Msg       [format(n! o)].
  op Producer             :                     -> Cid       [format (y! o)] .
  op cnt-prod:_           :  Nat                -> Attribute .
  op frequency:_          :  Nat                -> Attribute .
  op clock-p:_            :  Vector             -> Attribute  .
  op weights:_            :  Nat                -> Attribute .
  op end:_                :  Nat                -> Attribute .
  op finish:_             :  Bool               -> Attribute .
  op init-prod            :  Nat  Nat Nat Nat -> Object    .
  op Notice-logs:_        :  List{4Tuple}  ->  Attribute  .
  vars WE ST END FR : Nat .
  eq init-prod(ST,WE,FR,END)
   = < ST : Producer | finish: false , cnt-prod: 0 , weights: WE , frequency: FR , clock-p: 0 , end: END, Notice-logs: nil  > .
endm

mod CONSUMER is
  pr NAT . pr STRING  . pr LIST{String} . pr VECTOR . pr TUPLE .
  inc CONFIGURATION . pr LIST{3Tuple} .
  subsort Nat < Oid .
  --- Nat1: quien lo recive, Nat2: el que lo evio
  --- If you want to be precise, you may define another object: Sentinela.
  --- The Sentinela would take care of detec the Payload download in a Consumer.
  op init-consumer        :  Nat Nat Nat Vector     ->  Object     .
  op Consumer             :                         ->  Cid        [format (c! o)] .
  op Notice-mesg          :  Nat Nat Nat Vector     ->  Msg        [format(n! o)] .
  op none                 :                  ->  Msg     [ctor]   .
  op current-mesg:_       :  Msg             ->  Attribute  .
  op freq-C:_             :  Nat             ->  Attribute  .
  op actual-time:_        :  Nat             ->  Attribute  .
  op logs:_               :  List{3Tuple}    ->  Attribute  .
  op limit:_              :  Nat             ->  Attribute  .
  op clock-c:_            :  Vector          ->  Attribute  .
  var FR CO LT : Nat . var vec : Vector .
  eq init-consumer(CO,FR,LT,vec)
   = < CO : Consumer | clock-c: vec , freq-C: FR , actual-time: 0 , logs: nil , current-mesg: none, limit: LT  > .
endm

mod RULES is
  inc CONFIGURATION .
  pr CONVERSION .
  pr CONSUMER .
  pr PRODUCER .
  pr VECTOR .
  sort Sys .
  op {_} : Configuration -> Sys [format(n d d n)].
  vars N T T' FR CT' END PR CS LT : Nat .
  var CT TS CL VC : Vector .
  var ATS ATS' : AttributeSet .
  var Con : Configuration .
  var LP : List{4Tuple} .
  var QS : List{3Tuple} .

  crl [update-time-Producer] :
  { < PR : Producer | ATS ,  clock-p: CL , end: END , cnt-prod: CT' >  Con }
  =>
  { < PR : Producer | ATS ,  clock-p: tick(CL,PR)  , end: END , cnt-prod: CT'  >  Con }
  if CT' < END
  .
  crl [update-time-Consumer] :
  { < PR : Consumer | ATS , freq-C: FR , clock-c: CL , current-mesg: none ,  limit: LT >  Con }
  =>
  { < PR : Consumer | ATS , freq-C: FR , clock-c: tick(CL,PR) , current-mesg: none ,  limit: LT >  Con }
  if ic(CL,PR) <= LT
  .

  crl [send-msg]:
   { < PR : Producer | ATS , cnt-prod: N , weights:  T  , frequency: FR , clock-p: TS, end: END >  Con }
   =>
   { < PR : Producer | ATS , cnt-prod: s(N) , weights: T , frequency: FR , clock-p: tick(TS,PR), end: END  >
     Unordered-mesg(PR,N,T,TS)  Con }
  if FR divides ic(TS,PR) /\ (END > N) /\ (ic(TS,PR) =/= 0)
  .

  crl [Consumer-msg]:
    { Unordered-mesg(PR,N,T,TS)
     < CS : Consumer | ATS , current-mesg: none , freq-C: FR , clock-c: CL, limit: LT >  Con }
    =>
    {< CS : Consumer | ATS , current-mesg: Unordered-mesg(PR,N,T,TS) , freq-C: FR , clock-c: tick(maxv(CL,TS),CS) , limit: LT  >
     Notice-mesg(N,CS,PR,tick(maxv(CL,TS),CS)) Con }
   if (FR divides ic(CL,CS)) /\  ic(CL,CS) <= LT
   .

   --- (N,ic(CL,PR),CS,ic(VC,CS))

  ---  rl [Consumer-notice]:
  ---   { Notice-mesg(N,CS,PR,VC)
  ---    < PR : Producer | ATS ,clock-p: CL, Notice-logs: LP >  Con }
  ---   =>
  ---   {< PR : Producer | ATS ,clock-p: tick(maxv(CL,VC),PR),Notice-logs: ( LP  | N ; ic(CL,PR) ; CS ; ic(VC,CS) | )  >
  ---     Con }
  ---  .
  --- crl [Consuming-msg]:
  ---  {< CS : Consumer | ATS , actual-time: T' , logs: QS , clock-c: CL ,current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
  ---  =>
  ---  {< CS : Consumer | ATS , actual-time: s(T') , logs: QS , clock-c: tick(CL,CS) ,current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
  --- if  s(T') <= T
  --- .
  ---
  --- crl [end-msg]:
  ---  {< CS : Consumer | ATS , actual-time: T' , clock-c: CL , logs: QS , current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
  ---  =>
  ---  {< CS : Consumer | ATS , actual-time: 0 , clock-c: tick(CL,CS) ,logs: (QS (| PR ; N ; T | ) )  , current-mesg: none >  Con }
  --- if  T' = T
  --- .
  ---
  --- rl [send-end] :
  --- { < PR : Producer | ATS ,  cnt-prod: END , end: END , finish: false >  Con }
  --- =>
  --- { < PR : Producer | ATS ,  cnt-prod: END , end: END , finish: true > prod-finish(PR) Con }
  --- .


endm
--- search [1,50]
rewrite[4]
  {
--- < 0 : Producer | cnt-prod: 0,frequency: 1,clock-p: (0),weights: 5,end: 10,finish: false,Notice-logs: nil >
--- --- < 0 : Producer | cnt-prod: 0,frequency: 1,clock-p: (0 0 0 0 0),weights: 5,end: 10,finish: false,Notice-logs: nil >
--- --- < 1 : Producer | cnt-prod: 0,frequency: 3,clock-p: (0 0 0 0 0),weights: 1,end: 10,finish: false,Notice-logs: nil >
--- --- < 2 : Consumer | current-mesg: none,freq-C: 2,actual-time: 0,logs: nil,limit: 34, clock-c:(0 0 0 0 0) >
--- --- < 3 : Consumer | current-mesg: none,freq-C: 1,actual-time: 0,logs: nil,limit: 30, clock-c:(0 0 0 0 0) >
--- --- < 4 : Consumer | current-mesg: none,freq-C: 5,actual-time: 0,logs: nil,limit: 55, clock-c:(0 0 0 0 0) >
< 0 : Producer | cnt-prod: 1,frequency: 1,clock-p: (3 0 0 0 0),weights: 5,end: 4,finish: false,Notice-logs: nil >
< 1 : Producer | cnt-prod: 0,frequency: 3,clock-p: (0 2 0 0 0),weights: 1,end: 3,finish: false,Notice-logs: nil >
< 2 : Consumer | current-mesg: none,freq-C: 2,actual-time: 0,logs: nil,limit: 34, clock-c:(0 0 0 0 0) >
< 3 : Consumer | current-mesg: none,freq-C: 1,actual-time: 0,logs: nil,limit: 30, clock-c:(0 0 0 0 0) >
< 4 : Consumer | current-mesg: none,freq-C: 5,actual-time: 0,logs: nil,limit: 55, clock-c:(0 0 0 0 0) >
}
--- =>*
--- {
--- Con:Configuration < 0 : Producer | frequency: 3 , ATS:AttributeSet >
--- }
.
--- eof
