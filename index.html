<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>DRRF</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <header>
      <nav>
        <ul>
          <li><a href="#">Overview</a></li>
          <li><a href="examples.html">Examples</a></li>
        </ul>
      </nav>
    </header>

    <section class="main">
      <section class="articles">
        <article>
          <h2>DRRF</h2>
          <br>
          <p>
            We study the semantics of distributed reactive programming languages using rewriting logic. We propose a reactive event-based programming framework with explicit support for distribution, concurrency, and explicit time manipulation <i>DRRF</i> which has been developed on <i>Maude</i>.
          </p>
          <br>
          <p>
            Model distributed systems using Maude is a  straightforward task. They are modeled as entities, loosely coupled by some suitable communication mechanism. Maude provies a predefined module <code> CONFIGURATION</code> that declares sorts representing the essential concepts of object, attributes, message, along with a notation for object syntax. A configuration,base application, is a set of objects (Consumers & Producers) and messages that represents a snapshot of a possible system state. In this  framework  the entities are objects, each with a unique identity, and the communication mechanism is message passing using broadcast or unicast protocols.
          </p>
          <br>
          <p>
            The framework uses rewriting logic and includes a model of the distributed base application, a model of observables and observers, and a model for complex predicate constructs supporting explicit time manipulation.
          </p>
          <br>
          <h3>A review on Reactive Programming: Funtional Rective Programminge vs Rective programming </h3>
          <br>
          <!-- <p>DRRF framework is composed of differents Maude modules that model the dynamic behavior of a distributed reactive system. Thereby there are modules like Consumer-Base-Application, Producers-Base-Application, and Rules-Base-Application that specify the behavior of an environment where the observables issue data flow toward the system. Likewise, the module System-check-Base-Application introduces a formal model for a distributed observer that watches the data flow issue by an observable. Those observers watch data flow behavior and react to specific constraints model by LTL formulas that are model at module Temporal-Logic-Basic-Application.</p> -->
          <!-- La imagen que va en este lugar muestra la organizacionde los diferente modulos, mejorar la del paper -->
          <!-- <img src="html/imagenes/prueba.jpg" border="1" alt="Este es el ejemplo de un texto alternativo" width="400" height="300"> -->
        </article>
        <article>
          <h2>Modules</h2>
          <br>
          <p>DRRF framework is composed of several Maude modules thatj model the dynamic behavior of a distributed reactive system.</p>
          <br>
          <ul>
            <li><code>Base-Application.maude</code>: Specify the behavior of an environment where the observables issue data flow toward the system.</li>
            <li><code>Observers.maude</code>: Formal model for a distributed observer that watches the data flow issue by an observable.</li>
            <li><code>Temporal-logic.maude</code>: Formal model for LTL formulas.</li>
            <li><code>Predicates.maude</code>: Specify LTL predicates.</li>
            <li><code>Vector.maude</code>: Specify vector clocks using in the system.</li>
          </ul>
          <a href="https://github.com/Masanar/DRRF">Download</a>
        </article>

        <article>
          <h2>Observables: Producers and Consumers </h2>
          <br>
          <p>
            DRRF framework  defines two types of observables: Producers and Consumers. These observables are use to simulate the base application behavior. In this way, the Producers issue messages to the system and  Consumers read those messages.
          </p>
          <br>
          <p>
            There are several attributes that allow the consumers definition. For example, Producers and Consumers have attribute <code>frequency</code> that model at which frequency the Producer issue a message and at frequency which the Consumer read, this attribute is invariant throughout the execution. Consumers have attributes for recording message issue and message consuption for Producers(<code>logs</code>) and Consumers(<code>Notice-logs</code>) correspondingly.
          </p>
          <br>
          <p>
            As we mentioned above we use the module <code>CONFIGURATION </code> aiming to  define the particular objects, messages, and rules for interaction that are of interest. Thus, part of the definition to Producers is the follow:
          </p>
          <br>
          <br>
          <pre><code>
            mod PRODUCER is
              ...
              pro CONFIGURATION .
              subsort Nat < Oid .
              op Producer      :                     -> Cid      .
              op prod-finish   :  Nat                -> Msg      .
              op clock-p:_     :  Vector             -> Attribute .
              op finish:_      :  Bool               -> Attribute .
              op cnt-prod:_    :  Nat                -> Attribute .
              op frequency:_   :  Nat                -> Attribute .
              op weights:_     :  Nat                -> Attribute .
              op end:_         :  Nat                -> Attribute .
              op Notice-logs:_ :  List{4Tuple}       -> Attribute .
              ...
            endm
          </code></pre>
          <br>
          <p>
            The module <code>PRODUCERS</code>  defines the attributes for any type of Producer object. Hence, there are attributes of type Bool as <code>finish</code> that report the state of the Producer, if it is True the Producer is allowed to send a message and if it is False it can not issue messages. Likewise, the attribute <code>clock-p</code> stores the vector clock associated with that Producer. Besides, object identifiers <code>Oid</code> are defined as natural numbers. Diferent object identifiers relate diferent observables.
          </p>
          <br>
          <p>
            In this way, if we want to model a 0-Producer that has issued 1 message, which issue frequency is 3 (i.e each three ticks of his clock he is available to issue a message), each message issue by this Producer has a weight of 2 (i.e the Consumer who reads those message would take 2 tick to consume it) and his list of notice logs is empty (at the moment   Producer not received the notification that a Consumer has read his message) the follow the syntax for it :
          </p>
          <br>
          <pre><code>
            < 0 : Producer | cnt-prod: 1,frequency: 3,weights: 2,Notice-logs: nil,clock-p: 5,end: 4,finish: false >
          </code></pre>
          <br>
          <p>
            Furthermore, the syntax for Consumer is almots the same. The different is the attribute definition, which is modeled in module <code>CONSUMER</code>.
          </p>
          <br>
          <pre><code>
            mod CONSUMER is
              ...
              op Consumer             :                         ->  Cid      .
              op current-mesg:_       :  Msg             ->  Attribute  .
              op clock-c:_            :  Vector          ->  Attribute  .
              op freq-C:_             :  Nat             ->  Attribute  .
              op actual-time:_        :  Nat             ->  Attribute  .
              op limit:_              :  Nat             ->  Attribute  .
              op logs:_               :  List{3Tuple}    ->  Attribute  .
              ...
            endm

          </code></pre>
          <br>
          <p>
            Anew the  model for a 2-Consumer who is not reading  messages, which frequency is 5 (i.e every five ticks of his clock he is available to read a message), who has not ever read messages and has a limit of 34 reading messages  has the following syntax:
          </p>
          <br>
          <pre><code>
             < 2 : Consumer | current-mesg: none,freq-C: 5,actual-time: 0,logs: nil,limit: 34, clock-c: 0 >
          </code></pre>
          <br>
          <p>
            Notice that the dimension of the vector clock associated with each observer depends on the size of the entire base application. In this specification we an associate each Observable identification to his correspondent position in the clock thus observer 0 is associate whit position 0 in the vector clock, for more detail see the module <code>VECTOR</code>. In this way, a complex base application whit several observables, two Producers and four Consumers must have five dimensions and is modeling as follow:
          </p>
          <br>
          <pre><code>
            < 0 : Producer | cnt-prod: 0,frequency: 1,clock-p: (0 0 0 0 0),weights: 5,end: 4,finish: false,Notice-logs: nil >
            < 1 : Producer | cnt-prod: 0,frequency: 3,clock-p: (0 0 0 0 0),weights: 1,end: 3,finish: false,Notice-logs: nil >
            < 2 : Consumer | current-mesg: none,freq-C: 2,actual-time: 0,logs: nil,limit: 34, clock-c:(0 0 0 0 0) >
            < 3 : Consumer | current-mesg: none,freq-C: 1,actual-time: 0,logs: nil,limit: 30, clock-c:(0 0 0 0 0) >
            < 4 : Consumer | current-mesg: none,freq-C: 5,actual-time: 0,logs: nil,limit: 55, clock-c:(0 0 0 0 0) >
          </code></pre>
          <br>
          <h2>Observables: messages </h2>
          <br>
          <p>
             Maude also supports simple asynchronous message passing and complex patterns of synchronous interaction that can be used to model higher-level communication abstractions. For this propose we define in module <code>PRODUCER</code> the message <code>Unordered-mesg</code> who is the message that supports the communication between Producers and Consumers. In the same way, the message <code>Notice-mesg</code> is defined in module <code>CONSUMER</code> this type of message allows Consumer to notify the Producer that his message was consumed.
          </p>
          <br>
          <pre><code>
            mod PRODUCER is
              ...
              op Unordered-mesg:  Nat Nat Nat Vector -> Msg.
              ...
            endm


            mod CONSUMER is
              ...
              op Notice-mesg:     Nat Nat Nat Vector  ->  Msg.
              ...
            endm

          </code></pre>
          <br>
          <p>
            Therefore a snapshot of a system that has two Producers and three Consumers, as the previous example, but one the Producer has issued two message. One of those messages has been read by one Consumer and the other message has not been consumed. Can be model as follow:
          </p>

          <br>
          <pre><code>
            < 0 : Producer | cnt-prod: 4,frequency: 1,clock-p: (9 0 0 0 0),weights: 5,end: 4,finish: false,Notice-logs: nil >
            < 1 : Producer | cnt-prod: 3,frequency: 3,clock-p: (0 10 0 0 0),weights: 1,end: 3,finish: false,Notice-logs: nil >
            < 2 : Consumer | current-mesg: Unordered-mesg(0, 2, 5, 6 0 0 0 0),freq-C: 2,actual-time: 0,logs: nil,limit: 34,clock-c: (6 0 3 0 0) >
            < 3 : Consumer | current-mesg: Unordered-mesg(0, 1, 5, 4 0 0 0 0),freq-C: 1,actual-time: 0,logs: nil,limit: 30,clock-c: (4 0 0 1 0) >
            < 4 : Consumer | current-mesg: Unordered-mesg(0, 3, 5, 8 0 0 0 0),freq-C: 5,actual-time: 0,logs: nil,limit: 55,clock-c: (8 0 0 0 6) >
            Notice-mesg(1, 3, 0, 4 0 0 1 0)
            Notice-mesg(2, 2, 0, 6 0 3 0 0)
            Notice-mesg(3, 4, 0, 8 0 0 0 6)
            Unordered-mesg(1, 0, 1, 0 3 0 0 0)
            Unordered-mesg(1, 1, 1, 0 6 0 0 0)
            Unordered-mesg(1, 2, 1, 0 9 0 0 0)
          </code></pre>
          <br>

          <p>
            Notice that Unordered message have several elements, for example the <code>M</code> in the above example :
          </p>
          <br>
          <p>
            <ul>
              <li><code>Base-Application.maude</code>: Specify the behavior of an environment where the observables issue data flow toward the system.</li>
              <li><code>Observers.maude</code>: Formal model for a distributed observer that watches the data flow issue by an observable.</li>
              <li><code>Temporal-logic.maude</code>: Formal model for LTL formulas.</li>
              <li><code>Predicates.maude</code>: Specify LTL predicates.</li>
              <li><code>Vector.maude</code>: Specify vector clocks using in the system.</li>
            </ul>
          </p>
          <br>
          <p>
            At this point if you want to try the implementation u can use .... hacer ejemplos de rew  solo con Rules
          </p>

        </article>

      </section>
    </section>
    <footer>
      <p>
        Mateo Sanabria Ardila- Mateo.sanabria@escuelaing.edu.co
      </p>
    </footer>

  </body>
</html>
