<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>DRRF</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <header>
      <nav>
        <ul>
          <li><a href="#">Overview</a></li>
          <li><a href="examples.html">Examples</a></li>
        </ul>
      </nav>
    </header>

    <section class="main">
      <section class="articles">
        <article>
          <h2>DRRF</h2>
          <br>
          <p>
            We study the semantics of distributed reactive programming languages using rewriting logic. We propose a reactive event-based programming framework with explicit support for distribution, concurrency, and explicit time manipulation <i>DRRF</i> which has been developed on <i>Maude</i>.
          </p>
          <br>
          <p>
            Model distributed systems using Maude is a  straightforward task. They are modeled as entities, loosely coupled by some suitable communication mechanism. Maude provides a predefined module <code> CONFIGURATION</code> that declares sorts representing the essential concepts of object, attributes, message, along with a notation for object syntax. A configuration, base application, is a set of objects (Consumers & Producers) and messages that represent a snapshot of a possible system state. In this  framework, the entities are objects, each with a unique identity, and the communication mechanism is message passing using broadcast or unicast protocols.
          </p>
          <br>
          <p>
            The framework uses rewriting logic and includes a model of the distributed base application, a model of observables and observers, and a model for complex predicate constructs supporting explicit time manipulation.
          </p>
          <br>
          <!-- <h3>A review on Reactive Programming: Funtional Rective Programminge vs Rective programming </h3>
          <br> -->
          <!-- <p>DRRF framework is composed of differents Maude modules that model the dynamic behavior of a distributed reactive system. Thereby there are modules like Consumer-Base-Application, Producers-Base-Application, and Rules-Base-Application that specify the behavior of an environment where the observables issue data flow toward the system. Likewise, the module System-check-Base-Application introduces a formal model for a distributed observer that watches the data flow issue by an observable. Those observers watch data flow behavior and react to specific constraints model by LTL formulas that are model at module Temporal-Logic-Basic-Application.</p> -->
          <!-- La imagen que va en este lugar muestra la organizacionde los diferente modulos, mejorar la del paper -->
          <!-- <img src="html/imagenes/prueba.jpg" border="1" alt="Este es el ejemplo de un texto alternativo" width="400" height="300"> -->
        </article>
        <article>
          <h2>Modules</h2>
          <br>
          <br>
          <ul>
            <li><a href="/blob/gh-pages/Discrete Time/Reactive-XD/Rules-Base-Application.maude"><code>Base-Application.maude</code></a>: Specify the behavior of an environment where the observables issue data flow toward the system.</li>
            <li><code>Observers.maude</code>: Formal model for a distributed observer that watches the data flow issue by an observable.</li>
            <li><code>Temporal-logic.maude</code>: Formal model for LTL formulas.</li>
            <li><code>Predicates.maude</code>: Specify LTL predicates.</li>
            <li><code>Vector.maude</code>: Specify vector clocks using in the system.</li>
          </ul>
          <br>
        </article>

        <article>
          <h2>Observables: Producers and Consumers </h2>
          <br>
          <p>
            DRRF framework  defines two types of observables: Producers and Consumers. These observables are used to simulate the base application behavior. In this way, the Producers issue messages to the system and  Consumers read those messages.
          </p>
          <br>
          <p>
            There are several attributes that allow the consumers definition. For example, Producers and Consumers have attribute <code>frequency</code> that model at which frequency the Producer issue a message and at a frequency which the Consumer read, this attribute is invariant throughout the execution. Consumers have attributes for recording message issue and message consumption for Producers(<code>logs</code>) and Consumers(<code>Notice-logs</code>) correspondingly.
          </p>
          <br>
          <p>
            As we mentioned above we use the module <code>CONFIGURATION </code> aiming to  define the particular objects, messages, and rules for interaction that are of interest. Thus, part of the definition of Producers is the following:
          </p>
          <br>
          <br>
          <pre><code>
            mod PRODUCER is
              ...
              pro CONFIGURATION .
              subsort Nat < Oid .
              op Producer      :                     -> Cid      .
              op prod-finish   :  Nat                -> Msg      .
              op clock-p:_     :  Vector             -> Attribute .
              op finish:_      :  Bool               -> Attribute .
              op cnt-prod:_    :  Nat                -> Attribute .
              op frequency:_   :  Nat                -> Attribute .
              op weights:_     :  Nat                -> Attribute .
              op end:_         :  Nat                -> Attribute .
              op Notice-logs:_ :  List{4Tuple}       -> Attribute .
              ...
            endm
          </code></pre>
          <br>
          <p>
            The module <code>PRODUCERS</code>  defines the attributes for any type of Producer object. Hence, there are attributes of type Bool as <code>finish</code> that report the state of the Producer, if it is True the Producer is allowed to send a message and if it is False it can not issue messages. Likewise, the attribute <code>clock-p</code> stores the vector clock associated with that Producer. Besides, object identifiers <code>Oid</code> are defined as natural numbers. Different object identifiers relate to different observables.
          </p>
          <br>
          <p>
            In this way, if we want to model a 0-Producer that has issued 1 message, which issue frequency is 3 (i.e each three ticks of his clock he is available to issue a message), each message issue by this Producer has a weight of 2 (i.e the Consumer who reads those message would take 2 tick to consume it) and his list of notice logs is empty (at the moment   Producer not received the notification that a Consumer has read his message) the follow the syntax for it :
          </p>
          <br>
          <pre><code>
            < 0 : Producer | cnt-prod: 1,frequency: 3,weights: 2,Notice-logs: nil,clock-p: 5,end: 4,finish: false >
          </code></pre>
          <br>
          <p>
            Furthermore, the syntax for Consumer is almost the same. The difference is the attribute definition, which is modeled in module <code>CONSUMER</code>.
          </p>
          <br>
          <pre><code>
            mod CONSUMER is
              ...
              op current-mesg:_       :  Msg             ->  Attribute  .
              op clock-c:_            :  Vector          ->  Attribute  .
              op freq-C:_             :  Nat             ->  Attribute  .
              op actual-time:_        :  Nat             ->  Attribute  .
              op limit:_              :  Nat             ->  Attribute  .
              op logs:_               :  List{3Tuple}    ->  Attribute  .
              ...
            endm

          </code></pre>
          <br>
          <p>
            Anew the  model for a 2-Consumer who is not reading  messages, which frequency is 5 (i.e every five ticks of his clock he is available to read a message), who has not ever read messages and has a limit of 34 reading messages  has the following syntax:
          </p>
          <br>
          <pre><code>
             < 2 : Consumer | current-mesg: none,freq-C: 5,actual-time: 0,logs: nil,limit: 34, clock-c: 0 >
          </code></pre>
          <br>
          <p>
            Notice that the dimension of the vector clock associated with each observer depends on the size of the entire base application. In this specification, we associate each Observable identification to his correspondent position in the clock thus observer 0 is associate whit position 0 in the vector clock, for more detail see the module <code>VECTOR</code>. In this way, a complex base application whit several observables, two Producers and four Consumers must have five dimensions and is modeling as follow:
          </p>
          <br>
          <pre><code>
            < 0 : Producer | cnt-prod: 0,frequency: 1,clock-p: (0 0 0 0 0),weights: 5,end: 4,finish: false,Notice-logs: nil >
            < 1 : Producer | cnt-prod: 0,frequency: 3,clock-p: (0 0 0 0 0),weights: 1,end: 3,finish: false,Notice-logs: nil >
            < 2 : Consumer | current-mesg: none,freq-C: 2,actual-time: 0,logs: nil,limit: 34, clock-c:(0 0 0 0 0) >
            < 3 : Consumer | current-mesg: none,freq-C: 1,actual-time: 0,logs: nil,limit: 30, clock-c:(0 0 0 0 0) >
            < 4 : Consumer | current-mesg: none,freq-C: 5,actual-time: 0,logs: nil,limit: 55, clock-c:(0 0 0 0 0) >
          </code></pre>
          <br>
          <h2>Observables: messages </h2>
          <br>
          <p>
             Maude also supports simple asynchronous message passing and complex patterns of synchronous interaction that can be used to model higher-level communication abstractions. For this propose we define in module <code>PRODUCER</code> the message <code>Unordered-mesg</code> who is the message that supports the communication between Producers and Consumers. In the same way, the message <code>Notice-mesg</code> is defined in module <code>CONSUMER</code> this type of message allows Consumer to notify the Producer that his message was consumed.
          </p>
          <br>
          <pre><code>
            mod PRODUCER is
              ...
              op Unordered-mesg:  Nat Nat Nat Vector -> Msg.
              ...
            endm


            mod CONSUMER is
              ...
              op Notice-mesg:     Nat Nat Nat Vector  ->  Msg.
              ...
            endm

          </code></pre>
          <br>
          <p>
            Therefore a snapshot of a system that has two Producers and three Consumers, as the previous example. But in this case, 0-Producer has sent one message. The message issued by 0-Producer has been consumed by 3-consumer and the Consumer reacting to this whit a notice. The syntax is the following:
          </p>

          <br>
          <pre><code>
            < 0 : Producer | cnt-prod: 2,frequency: 1,clock-p: (5 0 0 0 0),weights: 5,end: 4,finish: false,Notice-logs: nil >
            < 1 : Producer | cnt-prod: 0,frequency: 3,clock-p: (0 2 0 0 0),weights: 1,end: 3,finish: false,Notice-logs: nil >
            < 2 : Consumer | current-mesg: none,freq-C: 2,actual-time: 0,logs: nil,limit: 34,clock-c: (0 0 1 0 0) >
            < 3 : Consumer | current-mesg: Unordered-mesg(0, 1, 5, 4 0 0 0 0),freq-C: 1,actual-time: 0,logs: nil,limit: 30,clock-c: (4 0 0 1 0) >
            < 4 : Consumer | current-mesg: none,freq-C: 5, actual-time: 0,logs: nil,limit: 55,clock-c: (0 0 0 0 0) >
            Notice-mesg(1, 3, 0, 4 0 0 1 0)
          </code></pre>
          <br>

          <p>
            Notice that messages issue by Producers have several elements, for example the <code>Unordered-mesg(0, 1, 5, 4 0 0 0 0)</code> in the above example :
          </p>
          <br>
          <p>
            <ul>
              <li> <code>0</code> is the identifier of the Producer that issued the message.
              <li><code>1</code> is the number of the message.</li>
              <li><code>5</code> is the weight of the message.</li>
              <li><code>4 0 0 0 0</code>is the snapshot of the Producer's clock when the message was issue.</li>
            </ul>
          </p>
          <br>
          <p>
            Similarly the Notice message has similar elements. For example the <code>Notice-mesg(1, 3, 0, 4 0 0 1 0)</code> in the above example :
          </p>
          <br>
            <ul>
              <li><code>1</code> is the number of the message.</li>
              <li> <code>3</code> is the identifier of the Consumer that read the message.
              <li> <code>0</code> is the identifier of the Producer that issued the message.
              <li><code>4 0 0 1 0</code>is the snapshot of the Consumer's clock when the message was read.</li>
            </ul>

          <br>
          <h2> Dynamic behavior</h2>
          <br>
          <p>
            In Maude, we have specified the rules that represent the dynamic behavior of the base application.  Rules model concurrent  transitions that can take place in system. If the pattern in the rule’s left-hand side matches a fragment of the system state and the rule’s condition is satisfied. In that case, the rule can take place, and the matched fragment of the state is transformed into the corresponding instance of the right-hand side.   In this way, several rules are defined. Notice that several variables are used because rules only need to mention the attributes and objects strictly necessary for model of concurrent transitions. Thus, <code>ATS</code> refers to a variable of type <code> AttributeSet </code> and <code>Con</code> refers to a variable of type <code>Configuration</code>, the other variables are related to his correspondent attribute type.
          </p>
          <br>


          <details>
            <summary> <code>[update-time-Producer]</code> </summary>
            <br>
            <p>
              This rule updates the individual internal vector clock of Producers. Using the <code>tick</code>  operation defined in module <code>VECTOR</code>; Furthermore, notice that this operation has two attributes <code>CL</code> the vector clock and <code>PR</code> the correspondent position in the vector clock associated with the specific Observable). This rule taking into account the restriction: The number of messages issued must  be less than the maximum level specified for each Productor (<code> CT'< END </code>).
            </p>
            <br>
            <pre><code>
              crl [update-time-Producer] :
              { < PR : Producer | ATS ,  clock-p: CL , end: END , cnt-prod: CT' >  Con }
              =>
              { < PR : Producer | ATS ,  clock-p: tick(CL,PR)  , end: END , cnt-prod: CT'  >  Con }
              if CT' < END
              .
            </code></pre>
            <br>
          </details>

          <details>
            <summary> <code>[update-time-Consumer]</code> </summary>
            <br>
            <p>
              This rule updates the individual internal vector clock of Consumers. Using the <code>tick</code>  operation defined in module <code>VECTOR</code>; Furthermore, notice that this operation has two attributes <code>CL</code> the vector clock and <code>PR</code> the correspondent position in the vector clock associated with the specific Observable). This rule taking into account the restriction: The individual clock must be less or equal than the maximum time specified for each Consumer (<code> ic(CL,PR) <= LT </code>).
            </p>
            <br>
            <pre><code>
              crl [update-time-Consumer] :
              { < PR : Consumer | ATS , freq-C: FR , clock-c: CL , current-mesg: none ,  limit: LT >  Con }
              =>
              { < PR : Consumer | ATS , freq-C: FR , clock-c: tick(CL,PR) , current-mesg: none ,  limit: LT >  Con }
              if ic(CL,PR) <= LT
              .
            </code></pre>
            <br>
          </details>

          <details>
            <summary> <code>[send-msg]</code> </summary>
            <br>
            <p>
              This rule add (creates) a new element into the Configuration, message type object. This rule taking into account three restrictions:
            </p>
            <br>
              <ul>
                <li><code>FR divides ic(TS,PR)</code> The frequency allows send message.</li>
                <li> <code>(END > N)</code> The amount of message production is less than the specific restriction for the Producer .
                <li> <code>(ic(TS,PR) =/= 0)</code> The individual clock already started.
              </ul>
            <br>
            <pre><code>
              crl [send-msg]:
               { < PR : Producer | ATS , cnt-prod: N , weights:  T  , frequency: FR , clock-p: TS, end: END >  Con }
               =>
               { < PR : Producer | ATS , cnt-prod: s(N) , weights: T , frequency: FR , clock-p: tick(TS,PR), end: END  >
                 Unordered-mesg(PR,N,T,TS)  Con }
              if FR divides ic(TS,PR) /\ (END > N) /\ (ic(TS,PR) =/= 0)
              .
            </code></pre>
            <br>
          </details>

          <details>
            <summary> <code>[Consumer-msg]</code> </summary>
            <br>
            <p>
              This rule model the message consumption for Consumers. Notice that pattern in the rule shows that message consumption implies tick the clock and read the message (i.e eliminate the message from Configuration and store at attribute <code>current-mesg</code>).
            </p>
            <br>
            <pre><code>
              crl [Consumer-msg]:
                { Unordered-mesg(PR,N,T,TS)
                 < CS : Consumer | ATS , current-mesg: none , freq-C: FR , clock-c: CL, limit: LT >  Con }
                =>
                {< CS : Consumer | ATS , current-mesg: Unordered-mesg(PR,N,T,TS) , freq-C: FR , clock-c: tick(maxv(CL,TS),CS) , limit: LT  >
                 Notice-mesg(N,CS,PR,tick(maxv(CL,TS),CS)) Con }
               if (FR divides ic(CL,CS)) /\  ic(CL,CS) <= LT
               .
            </code></pre>
            <br>
          </details>

          <details>
            <summary> <code>[Consumer-notice]</code> </summary>
            <br>
            <p>
              Perceive that pattern in this rule shows that notice message consumption for Producers implies tick the clock and record the notice logs. The <code>Notice-logs</code> is a list of <code>|N;ic(CL,PR);CS;ic(VC,CS)|</code> elements that allows get information of which Consumer <code>CS</code> read which message <code>N</code> at which time <code>ic(VC,CS)</code> additionally at which time the Producer read the notice message <code>ic(CL,PR)</code>.
            </p>
            <br>
            <pre><code>
              rl [Consumer-notice]:
               { Notice-mesg(N,CS,PR,VC)
                < PR : Producer | ATS ,clock-p: CL, Notice-logs: LP >  Con }
               =>
               {< PR : Producer | ATS ,clock-p: tick(maxv(CL,VC),PR),Notice-logs: ( LP  | N ; ic(CL,PR) ; CS ; ic(VC,CS) | )  >
                 Con }
              .
            </code></pre>
            <br>
          </details>

          <details>
            <summary> <code>[Consuming-msg]</code> </summary>
            <br>
            <p>
              The consumption of a message storing into a Consumer is done through the time, taking into account the message's weight <code>T</code>. Thus, the attribute <code>actual-time</code> is a counter that identifies how long the message has been consumed, each rule application implies a tick in the clock as well as a tick in this counter.
            </p>
            <br>
            <pre><code>
              crl [Consuming-msg]:
               {< CS : Consumer | ATS , actual-time: T' , logs: QS , clock-c: CL ,current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
               =>
               {< CS : Consumer | ATS , actual-time: s(T') , logs: QS , clock-c: tick(CL,CS) ,current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
              if  s(T') <= T
              .
            </code></pre>
            <br>
          </details>

          <details>
            <summary> <code>[end-msg]</code> </summary>
            <br>
            <p>
              Notice that pattern in this rule shows that end of consumption message implies tick the clock and record the message logs. The <code>logs</code> attribute is a list of <code>|PR;N;T|</code> elements that allows get information of which Producer <code>PR</code> issue which message <code>N</code> as well as the weight of it <code>T</code>.
            </p>
            <br>
            <pre><code>
              crl [end-msg]:
               {< CS : Consumer | ATS , actual-time: T' , clock-c: CL , logs: QS , current-mesg: Unordered-mesg(PR,N,T,TS) >  Con }
               =>
               {< CS : Consumer | ATS , actual-time: 0 , clock-c: tick(CL,CS) ,logs: (QS (| PR ; N ; T | ) )  , current-mesg: none >  Con }
              if  T' = T
              .
            </code></pre>
            <br>
          </details>

          <details>
            <summary> <code>[send-end]</code> </summary>
            <br>
            <p>
              This rule issue a message <code>prod-finish(PR)</code> when the producer reaches the limit of messages that it can be issued.
            </p>
            <br>
            <pre><code>
              rl [send-end] :
              { < PR : Producer | ATS ,  cnt-prod: END , end: END , finish: false >  Con }
              =>
              { < PR : Producer | ATS ,  cnt-prod: END , end: END , finish: true > prod-finish(PR) Con }
              .
            </code></pre>
            <br>
          </details>
          <br>

        </article>

        <article>
          <h2>Observers</h2>
          <br>
          <p>
            We use LTL operators to specify behavior in the reactive base application and the data flow throughout the execution system. The module <code>LTL</code>  defines the temporal logic operators as Maude operations. However, it is necessary to define the semantics of these operators
          </p>
          <br>
        </article>

      </section>
    </section>
    <footer>
      <p>
        Mateo Sanabria Ardila- Mateo.sanabria@escuelaing.edu.co
      </p>
    </footer>

  </body>
</html>
